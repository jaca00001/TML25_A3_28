from tqdm import tqdm
import torch
import torch.nn as nn
from src.attacks import *

# Trains tge model, can be turned into adversarial training by setting adv=True.
# Allows to use a clean model to generate adversarial samples
def train(model, loader, adv=False, clean=None):
    model.train()
    model = model.cuda()
    device = next(model.parameters()).device

    optimizer = torch.optim.Adam(model.parameters())
    criterion = nn.CrossEntropyLoss()

    losses = []

    for _, imgs, labels in tqdm(loader, leave=False):
        imgs = imgs.to(device=device, dtype=torch.float32)
        labels = labels.to(device=device, dtype=torch.long)
       

        # If adversarial training is enabled, we generate adversarial samples
        if adv == True:

            # Change the model to clean to use another model for gnenerating adversarial samples
            adv_imgs = pgd_attack(model, imgs, labels).detach()

            clean_pred = model(imgs)
            adv_pred = model(adv_imgs)
 
            loss = criterion(clean_pred, labels) + criterion(adv_pred,  labels)
        else:
            pred_label = model(imgs)
            loss = criterion(pred_label, labels)

        losses.append(loss.item())
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    avg_loss = sum(losses)/len(losses)
    return avg_loss


# Evaluates the model on the test set, optionally using adversarial samples generated by PGD attack.
def evaluate(model, test_loader, epsilon):
    model.eval()
    correct = 0
    total = 0
    model = model.to("cuda")
    device = next(model.parameters()).device

    for _, imgs, labels in tqdm(test_loader, leave=False):
        imgs = imgs.to(device=device, dtype=torch.float32)
        labels = labels.to(device=device, dtype=torch.long)

        if epsilon > 0:
          imgs = pgd_attack(model, imgs, labels, eps=epsilon).detach()

        output = model(imgs)
        pred = output.argmax(1)
        correct += (pred == labels).sum().item()
        total += labels.size(0)

    acc = 100. * correct / total
    return acc


import matplotlib.pyplot as plt

def plot_loss(train_loss, test_accuracy, filename="out/plots/loss.png"):
    plt.figure(figsize=(10, 5))
    plt.plot(train_loss, label='Train Loss')
    plt.plot(test_accuracy, label='Test Accuracy')
    plt.xlabel('Epochs')
    plt.ylabel('Loss / Accuracy')
    plt.title('Training Loss and Test Accuracy')
    plt.legend()
    plt.grid()
    plt.savefig(filename)
    plt.close()  