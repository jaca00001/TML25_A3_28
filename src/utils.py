from tqdm import tqdm
import torch
import torch.nn as nn
from src.attacks import *
import requests
import torch
import torch.nn as nn
from torchvision import models
import torch
import matplotlib.pyplot as plt


# Trains tge model, can be turned into adversarial training by setting adv=True.
# Allows to use a clean model to generate adversarial samples
def train(model, loader, adv=False, clean=None):
    model.train()
    model = model.cuda()
    device = next(model.parameters()).device

    optimizer = torch.optim.Adam(model.parameters())
    criterion = nn.CrossEntropyLoss()

    losses = []
    
    # Weight for the adversarial loss if adv is True
    lambda_ = 0.5  

    for _, imgs, labels in tqdm(loader, leave=False):
        imgs = imgs.to(device=device, dtype=torch.float32)
        labels = labels.to(device=device, dtype=torch.long)
       

        # If adversarial training is enabled, we generate adversarial samples
        if adv == True:

            # Change the model to clean to use another model for gnenerating adversarial samples
            adv_imgs = pgd_attack(model, imgs, labels).detach()

            clean_pred = model(imgs)
            adv_pred = model(adv_imgs)
 
            loss = criterion(clean_pred, labels) + lambda_ *  criterion(adv_pred,  labels)
        else:
            pred_label = model(imgs)
            loss = criterion(pred_label, labels)

        losses.append(loss.item())
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    avg_loss = sum(losses)/len(losses)
    return avg_loss


# Evaluates the model on the test set, optionally using adversarial samples generated by PGD attack.
def evaluate(model, test_loader, epsilon):
    model.eval()
    correct = 0
    total = 0
    model = model.to("cuda")
    device = next(model.parameters()).device

    for _, imgs, labels in tqdm(test_loader, leave=False):
        imgs = imgs.to(device=device, dtype=torch.float32)
        labels = labels.to(device=device, dtype=torch.long)

        if epsilon > 0:
          imgs = pgd_attack(model, imgs, labels, eps=epsilon).detach()

        output = model(imgs)
        pred = output.argmax(1)
        correct += (pred == labels).sum().item()
        total += labels.size(0)

    acc = 100. * correct / total
    return acc


def plot_loss(train_loss, test_accuracy, filename="out/plots/loss.png"):
    plt.figure(figsize=(10, 5))
    plt.plot(train_loss, label='Train Loss')
    plt.plot(test_accuracy, label='Test Accuracy')
    plt.xlabel('Epochs')
    plt.ylabel('Loss / Accuracy')
    plt.title('Training Loss and Test Accuracy')
    plt.legend()
    plt.grid()
    plt.savefig(filename)
    plt.close()  
    
    
def upload(path,model_type):
    ### Tests ###
    allowed_models = {
        "resnet18": models.resnet18,
        "resnet34": models.resnet34,
        "resnet50": models.resnet50,
    }
    with open(path, "rb") as f:
        try:
            model: torch.nn.Module = allowed_models[model_type](weights=None)
            model.fc = torch.nn.Linear(model.fc.weight.shape[1], 10)
        except Exception as e:
            raise Exception(
                f"Invalid model class, {e=}, only {allowed_models.keys()} are allowed",
            )
        try:
            state_dict = torch.load(f, map_location=torch.device("cpu"),weights_only=False)
            model.load_state_dict(state_dict, strict=True)
            model.eval()
            out = model(torch.randn(1, 3, 32, 32))
        except Exception as e:
            raise Exception(f"Invalid model, {e=}")

        assert out.shape == (1, 10), "Invalid output shape"

    TOKEN = "08392413"

    # Send the model to the server, replace the string "TOKEN" with the string of token provided to you
    response = requests.post("http://34.122.51.94:9090/robustness", files={"file": open(path, "rb")}, headers={"token": TOKEN, "model-name": model_type})

    # Should be 400, the clean accuracy is too low
    print(response.json())
